\section{Hintergrund}
    \at{@incomplete Einleitender Satz, was zu prozeduraler Generierung}

\subsection{Gitter, Graphen, Triangulierung, Voronoi}
    \at{@incomplete Definition von Gitter und Graph in dieser Arbeit}
    
    \url{https://en.wikipedia.org/wiki/Delaunay_triangulation}\\
    \url{https://en.wikipedia.org/wiki/Voronoi_diagram}\\
    \url{https://de.wikipedia.org/wiki/Polygonnetz}\\
    \url{https://en.wikipedia.org/wiki/Triangulated_irregular_network}\\
    \url{https://en.wikipedia.org/wiki/Lattice_graph}\\
    
    \subsubsection{Gitter}
    \subsubsection{Graphen}
    \subsubsection{Triangulierung, Quadrilierung}
    \subsubsection{Delaunay Triangulation}
        \begin{itemize}
        \item Defintion der Triangulierung
        \item \at{@visual}
        \end{itemize}
    \subsubsection{Voronoi Diagramm}
        \begin{itemize}
        \item Definition
        \item nützliche Eigenschaften
        \end{itemize}
    \subsubsection{Oskar Stålberg}
        \at{@incomplete WFC on irregular quadrilations, Oskar Stålberg}
        \begin{itemize}
        \item usage in Bad North and Town Scaper
        \item aperiodic infinite deterministic irregular relaxed quadrilateral grids
        \end{itemize}
        

\section{Konzept}
    \at{@incomplete Einleitender Satz}
    
    \subsection{Einschränkung des Algorithmus und Idee zur Erweiterung}
        \at{@placement Kann das ausfallen?}
        Wenn man mit WFC eine Ausgabe erstellen will, die sich selbst tiled \at{@translation} (also linker Rand gleich rechter Rand und so) kann man eine imaginäre Kante von einer Zelle am rechten Rand zu einer Zelle am linken Rand erstellen und dem Algorithmus definieren dass diese Benachbarung in Richtung Osten geht. Nun sind die Ränder des Gitters benachbart und das Ergebnis ist, dass die Ränder, wenn eine Lösung gefunden wird, zueinander passen. Wenn man dies für einen Rand macht, so ist die Form der Zellen mit ihren Nachbarn nicht mehr eine flache Ebene, sondern die Oberfläche eines Zylinders(ohne Deckel und Boden). Verbindet man auf die selbe Weise auch den anderen Rand, ist die Form nun ein Torus. Der Algorithmus selbst muss also nur auf diese Weise angepasst werden, um auf anderen Anordnungen von Zellen zu funktionieren.
    
\section{Umsetzung}
    \at{@incomplete Einleitender Satz}
    
    \subsection{Generierung von Voronoi-Graphen}
        
        Für die Triangulierung habe ich mich ohne tiefere Beweggründe für den Boywer-Watson Algorithmus entschieden. Der Algorithmus generiert die Triangulierung iterativ in dem jeder Punkt nacheinander eingefügt wird und der Graph angepasst wird, so dass es wieder eine Delaunay-Triangulierung ist.
        Zur Hilfe erstellen wir ein Superdreieck, welches alle Punkte enthällt. Nun fügen wir einen Punkt ein und prüfen all bisher gefundenen Dreiecke, ob ihr Umkreis diesen Punkt enhällt. Ist der Punkt innerhalb des Umkreises kann das Dreieck nicht zur finalen Triangulierung gehören. Für alle diese Dreieck sammeln wir nun die Kanten. Jede Kante die nur einmal vorkommt ist teil der Hülle dieser Dreiecke, alle anderen Kanten sind innerhalb dieser Hülle, da sich zwei Dreiecke diese teilen. Diese inneren Kanten werden entfernt und für jede Ecke entlang der Hülle wird eine neue Kante zum eingefügten Punkt erstellt.
        Am Ende entfernt alle Kanten zur den Eckpunkten des Superdreiecks aus der Triangulierung und erhällt die Delaunay-Triagulierung der Point-Cloud.
        
        Aus der Triangulierung erstellen wir das Voronoidiagram indem wir die Eckpunkte als Mittelpunkte der Voronoizellen nehmen. Die Kanten sagen uns welche Zellen benachbart sind. Um die Kanten der Voronoizelle zu finden nehmen wir von alle Dreiecke in denen der Punkt liegt den Mittelpunkt des Umkreises. Die Umkreismittelpunkte sind die Ecken der Voronoizelle. Die Kanten finden wir indem wir die Punkte nach ihrem Winkel um den Mittelpunkt der Zelle sortieren und dann der Reihe nach verbinden.
        
        Es ist normal, dass ein solches Voronoidiagram an den Rändern der Point-Cloud auch Zellen ergeben kann die auf einer Seite offen sind, weil die Kanten zwischen den Ecken der Zelle, den Umkreismittelpunkten, keinen Schnittpunkt haben. Ich habe mich dazu entschieden, bei solchen Zellen weitere Eckpunkte einzufügen, so dass das alle Zellen durch einen freigewählten rechteckigem Bereich begrenzt sind. Dafür prüfe ich ob ein Eckpunkt außerhalb des Bereichs liegt und finde dann den Schnittpunkt von der Kante zu dem Eckpunkt mit dem Rechteck des Bereichs und ersetze den Eckpunkt mit diesem Schnittpunkt. Dieser Schritt passiert so lange bis alle Eckpunkte innerhalb oder auf dem Rand des Bereichs liegen.
            Siehe Abbildung \ref{fig:voronoi_clipping}.
            
            
\section{Ergebnisse}
    \begin{itemize}
    \item Base Case - Gitter
    \item Graphen
    \item Bilder
    \end{itemize}
    
    
\section{Diskussion}
    \begin{itemize}
    \item Lokale Ähnlichkeit im Vergleich zum Input
    \item Pixel/Linienmuster und Flächenmuster
    \item Zu kleiner Lösungsraum ergibt uniformen Output, nur eine Farbe die flächenartig ist.
    \item Vergleich zum Original
    \item Mögliche Anwendungsbereiche
    \end{itemize}
    
    \subsection{Ausblick und zukünftige Forschung}
        \begin{itemize}
        \item WFC auf 3D Graphen
        \item Eigenschaften des Musters(Linien und Flächen) in Bezug auf Heat
        \item Eigenschaften des Gitters analysieren, Engpässe, unförmige Zellen, Abstände, Form der Zelle beachten
        \end{itemize}
        
        \subsubsection{Heat}
            \begin{itemize}
            \item Eine globale Heat für alle Zellen hat einen negativen Effekt auf lokal regelmäßige Regionen eines Gitters und ein postiven Effekt auf sehr unregelmäßige Regionen des Gitters.
            \item Anstatt dass die Heat global für alle Zellen zu Beginn bestimmt wird, kann man auch während des Collapse 'lernen' welche Regionen 'schwerer' zu lösen sind und dort die Heat schrittweise erhöhen bis eine Lösung gefunden werden kann.
            \item Lokales Heating mit heating chance und cooling chance
            \item simmulated annealing
            \end{itemize}