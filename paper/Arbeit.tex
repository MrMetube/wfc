\documentclass[12pt,a4paper,oneside]{scrreprt}

\usepackage[T1]{fontenc}    % bessere Akzente auf äöü
\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} % Deutsche Begriffe
\usepackage{lmodern}        % bessere Schriftart

\usepackage{hyperref}                          % clickable links
\usepackage{amsmath, amssymb}                  % mathe formeln
\usepackage{graphicx, caption, subcaption}     % for figures and subfigures
\captionsetup[figure]{font=small,format=plain} % figure caption style

\usepackage{float}                             % enforce figure placement
\usepackage{setspace}                          % line doublespacing...
\usepackage{geometry}
\geometry{left=3.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter \renewcommand{\ALG@name}{Algorithmus} \makeatother

% ////////////////////////////////////////////////

% 
% @important
% 
% Vor Abgabe löschen:
% 

\usepackage{xcolor}
\definecolor{mred}{HTML}{fe163d}
\definecolor{mgreen}{HTML}{009052}
\definecolor{mblue}{HTML}{586076}
\DeclareRobustCommand{\@todo(viktor):}[1]{
    \textcolor{mred}{@todo:} \textcolor{mred}{#1}
} 
\DeclareRobustCommand{\at}[1]{
    \textcolor{mgreen}{#1}
}



% ////////////////////////////////////////////////



\begin{document}

% 
% @important
% Vor Abgabe:
% 

\@todo(viktor):{pdf in git laden}

\@todo(viktor):{Abbildungen Anordung verbessern in Kapitel 2 und 5}

% 
% @important
% Abgabe:
% 
\@todo(viktor):{Die Selbstständigkeitserklärung unterschreiben}

\@todo(viktor):{Die PDF an:
    stefan.schlechtweg@hs-anhalt.de
    anika.gross@hs-anhalt.de
    axel.schneider@hs-anhalt.de
    pruefungsamt-koethen@hs-anhalt.de
}

\input{1.tex}

\chapter{Hintergrund}
    In diesem Kapitel werden zuerst einige grundlegende Begriffe erklärt. Danach wird auf die Algorithmen, auf denen diese Arbeit basiert, eingegangen. Dies sind \textit{Model Synthesis} von Merrel \cite{merrel} und dessen Weiterentwicklung \textit{Wave Function Collapse} von Gumin \cite{gumin}.
    
    \section{Begriffserklärung}
        Ein \textit{Gitter} beschreibt eine regelmäßig aufgebaute Struktur aus einzelnen Punkten. Diese Knotenpunkte sind durch Kanten mit ihren direkten Nachbarn verbunden. Ein Bild wird digital z.B. auf einem Gitter von Pixeln gespeichert und dargestellt. Genauso bilden die Kästchen eines Sudoku ein Gitter. Wenn solch ein Gitter in einer Ebene liegt, wird es auch als \textit{2D Gitter} bezeichnet. Sind die Punkte regelmäßig im Raum angeordnet spricht man von einem \textit{3D Gitter}. Ein \textit{Graph} besteht aus einer Menge an Knoten $V$ und einer Menge an Kanten $E$, wobei eine Kante ein Knotenpaar aus $V$ ($\{v_1, v_2\} \in V$) ist. Die Knotenpunkte können eine beliebige Anordnung haben und beliebig mit anderen Knoten durch Kanten verbunden sein. Ein Gitter ist eine spezielle Form eines Graphen, bei die Knoten enlang von festen Achsen angeordnet werden und nur Kanten entlang dieser Achse so den nächstliegenden Knoten existieren.
        \\
        \\
        Eine \textit{Triangulierung} ist ein Graph, dessen Knoten und Kanten Dreiecke aufspannen. Eine besonders wichtige Variante ist die \textit{Delaunay-Triangulierung} \cite{delaunay}, bei der die Dreiecke so gewählt werden, dass der kleinste Winkel innerhalb jedes Dreiecks möglichst groß ist. Dadurch entstehen „gut geformte“ Dreiecke. Eng verwandt damit ist das \textit{Voronoi-Diagramm} \cite{voronoi}. Es teilt die Ebene in Regionen auf, sodass jeder Punkt genau die Fläche erhält, die ihm am nächsten liegt. Die Delaunay-Triangulierung und das Voronoi-Diagramm sind dual zueinander: Verbindet man die Mittelpunkte der Voronoi-Zellen, entsteht die Delaunay-Triangulierung, und aus einer Delaunay-Triangulierung lässt sich wiederum das zugehörige Voronoi-Diagramm ableiten. In Abbildung \ref{fig:delaunay_voronoi} ist die Delaunay-Triangulierung und das Voronoi-Diagram für einige Punkte dargestellt.
        
        \input{data/delaunay_voronoi/figure.tex}
        
        Unter \textit{Prozedurale Generierung} versteht man Algorithmen, die Inhalte wie z.B. Bilder, 3D Modelle oder Musik erzeugen können. Meist nimmt ein solcher Algorithmus nur eine kleine Menge an Daten als Eingabe und generiert daraus viele Variationen an Ausgaben. Dabei werden häufig Zufallszahl-Generatoren benutzt, aber der Ablauf ist nicht rein zufällig. Bei gleicher Initialisierung generiert ein solcher Algorithmus immer die selbe Ausgabe und kann durch Parameter gesteuert werden. Prozedurale Generierung wird in Computerspielen regelmäßig verwendet, da es den Entwicklern erlaubt den Spielern viele varierte Inhalte zu bieten, ohne diese alle vorher manuell anzufertigen und fest im Spiel einzubauen.
    
    \section{Model Synthesis}
        Mit dem \textit{Model Synthesis} \cite{merrel} Algorithmus \ref{alg:ms_merrel} können, basiert auf einem 3D Beispielmodell, eine große Menge an ähnlichen 3D Modellen prozedural generiert werden (siehe Abbildung \ref{fig:ms_output}). Das Beispielmodell muss zuvor in kleinere Bauteile zerlegt werden, aus denen der Algorithmus dann ein neues Modell generiert. Ein Bauteil kann ein komplexer Teil des Beispiels sein, kann aber auch einen leeren Teil des Beispiels enthalten. Die Bauteile werden wie Bauklötze zusammengebaut, wobei zwei Bauteile nur dann nebeneinander platziert werden dürfen, wenn diese auch im Beispielmodell nebeneinander vorkommen. Diese Eigenschaft wird auch Konsistenz genannt. Ein simples konsistentes Modell ist z.B. ein leeres Modell.
        
        Der Algorithmus arbeitet auf einem 3D Gitter. Jedem Knotenpunkt des Gitters wird im fertigen Modell ein Bauteil zugewiesen, doch vorher könnten an jedem Knotenpunkt mehrere Bauteile ein konsistentes Modell bilden. Der Algorithmus wählt iterativ ein Bauteil und prüft, dass dadurch kein anderer Knotenpunkt nun keine möglichen Bauteile mehr hat. Wäre dies der Fall, so könnte das Modell nicht mehr vervollständigt werden. Hierfür wird eine globale Suche verwendet, andere Methoden beschränkten sich zuvor nur auf lokale Suchen. Eine globale Suche hat zum Vorteil, dass auch ein weitreichenden Einfluss eines Bauteils auf das gesamte Gitter korrekt behandelt wird. Die Auswahl der Bauteile geschieht per Zufall, dabei werden Bauteile die oft im Beispiel vorkommen wahrscheinlicher ausgewählt als seltene Bauteile. Für eine generiertes Modell bedeutet dies, dass die globale Verteilung der Bauteile auch tendenziell der Verteilung im Beispiel gleicht.
        
        \input{data/ms_output/figure.tex}
        \input{data/ms_merrel.tex}
        \input{data/ms_algorithm/figure.tex}
        
        Die selbe Methodik kann auch für Beispielbilder benutzt werden, dies wird dann auch \textit{Texture Synthesis} genannt. In diesem Fall arbeitet der Algorithmus mit 2D Gittern und Bauteilen. Die Ausgabe des Algorithmus kann auch durch Soft-Constraints beschränkt werden (siehe Abbildung \ref{fig:ms_constrained}). Ebenso kann Symmetrie, Spiegelung und Drehung, in der Ausgabe erzwungen werden. Beide Ansätze wurden nicht weiter in dieser Arbeit betrachetet. Es wird empfohlen, dass der Algorithmus nicht das ganze Gitter auf einmal löst, damit Widersprüche nicht zu einem kompletten Neustart führen. Stattdessen sollen iterativ kleine Abschnitte für sich solange gelöst werden bis eine valide Ausgabe entsteht (siehe Abbildung \ref{fig:ms_algorithm}). In dieser Arbeit wurde darauf verzichtet.
        
        \input{data/ms_constrained/figure.tex}
    
    
    \section{Wave Function Collapse}
        \textit{Wave Function Collapse} \cite{gumin} ist eine Weiterentwicklung des Model Sythesis Algorithmus \ref{alg:wfc_gumin}. Abbildung \ref{fig:wfc_overview} zeigt einige Beispiele und daraus generierte Bilder. Der Name ist eine Anspielung auf die Quantenphysik. So könnte man Quantenpartikel in Superposition mit den Zellen des Gitters vergleichen. Die Zellen haben auch mehrere mögliche finale Zustände bis sie observiert werden und in einen festen Zustand kollabiert. Mathematisch besteht aber keine Beziehung. Auch werden andere Begriffe wie z.B. Knoten zu Zelle umbenannt und das Gitter als Wave bezeichnet. Die Kernidee der Generierung mittels einem Beispiel bleibt und wird um drei Aspekte erweitert:
        
        \begin{enumerate}
        \item Bauteile können automatisch aus einem Beispiel extrahiert werden.
        \item Im Algorithmus werden die Zellen beginnend mit der niedrigsten Entropie abgearbeitet. 
        \item Spiegelungen und Reflexionen von Bauteilen werden automatisch erzeugt und verwendet.
        \end{enumerate}
        
        \input{data/wfc_gumin.tex}
        \input{data/wfc_overview/figure.tex}
        
        
        \subsection{Entropie}
            Bei Model Synthesis werden Zellen einfach nach ihrer Reihenfolge im Gitter abgearbeitet. Der Vorteil ist, dass keine Suche der nächsten Zelle nötig ist, aber es hat zum Nachteil, dass die Ausgabe sichtbare Artefakte enthällt (siehe Abbildung \ref{fig:directional_bias}). Man kann erkennen, ob zuerst die Reihen oder erst die Spalten abgearbeitet wurden. Wäre bekannt welche Zelle den meisten Fortschritt zur Lösung und die geringste Chance auf einen Widerspruch birgt, könnte stets diese Zelle zuerst betrachtet werden. 
            
            \input{data/directional_bias/figure.tex}
            
            Merrel zeigt im Anhang seines Papers \cite{merrel}, dass die Entscheidung, ob eine Ausgabe vervollständigt werden kann, ein NP-vollständiges Problem ist. Einfacher ist es eine Heuristik zu definieren. Hierfür wird die Shannon-Entropie \cite{shannon} als Maß eingeführt. Sie beschreibt das Maß an Ungewissheit in einem System, hier die Ungewissheit über den finalen Zustand einer Zelle. Sie wird mit der Formel \ref{eq:entropy} berechnet, wobei $\mathcal{X}$ die Menge der möglichen Zustände einer Zelle ist und $p(x)$ die Wahrscheinlichkeit das $x$ gewählt wird ist.
            
            Ist eine Zelle observiert, hat sie nur noch einen Zustand und die Entropie ist 0, während eine Zelle mit vielen Möglichkeiten eine hohe Entropie hat. Die Entropie gibt auch Information darüber wie sehr eine Zelle durch ihre Umgebung beschränkt wird, weil Zellen mit vielen Beschränkungen nur noch wenige mögliche Zustände haben.  
                       
            \input{data/entropy.tex}
        
        
        \subsection{Symmetrie}
            Ziel des Model Synthesis Algorithmus ist es, eine große Anzahl lokal ähnlicher Ausgaben zu generieren \cite{merrel}. Ähnlichkeit wird erreicht, wenn jede kleine Region der Ausgabe zu Regionen des Beispiels passt (siehe Abbildung \ref{fig:wfc_resemblance}). Die wahrgenommene Ähnlichkeit wird verbessert, wenn das Verhältnis der Häufigkeiten von Regionen der Verteilung im Beispiel gleicht. Im Wave Function Collapse wird dieses Kriterium erweitert. Die Regionen können nun auch Drehungen und Spiegelungen der Regionen im Beispiel sein \cite{gumin}.
            
            \input{data/wfc_resemblance/figure.tex}
            
            Desweiteren wird auch eine Annotation für manuell erstellten Bauteile definiert, mit der ein Nutzer einem Bauteil eine Symmetriegruppe zuweisen kann \cite{gumin}. Eine Symmetriegruppe gibt an, wie man ein Bauteil drehen und spiegeln kann. Beim Einlesen generiert der Algorithmus basiert auf dieser Symmetriegruppe weitere, entsprechend gedreht oder gespiegelte, Bauteil die im weiteren Prozess verwendet werden. Da sich diese Arbeit nicht mit Beispielen aus Bauteilen befässt sondern primär diese automatisch extrahiert, bleibt dieser Aspekt ungenutzt.
        
        
        \subsection{Extraktion}
            Zuvor musste der Nutzer das gewünschte Beispielmodell oder Beispielbild manuell in einzelne gleichgroße Bauteile zerlegen, aus denen der Algorithmus dann neue Modelle und Bilder generiert. Wave Function Collapse nutzt einen Algorithmus \ref{alg:wfc_extraction} zur Generierung dieser Bauteile \cite{gumin}. Die größe der Bauteile ist dabei freiwählbar, aber sie sollte so gewählt sein, das sie zum genutzen Beispiel passt, damit die im Beispiel existierenden Muster erhalten bleiben.  Sind die Bauteile zu klein gewählt, gehen Strukturen des Beispiels verloren. Während zu große Bauteile auch unerwünschte Strukturen im Beispiel enthalten, was im extremen Fall dazu führt, dass nur noch exakte Kopien des Beispiels ohne Variation in der Ausgabe vorkommen. Für Bilder wird in dieser Arbeit stets die Moore-Nachbarschaft jedes Pixels, also die direkt angrenzenden Pixel sowie die entlang der Diagonalen, als Bauteil verwendet. Dies wird auch als das Umfeld des Pixels beschrieben.
            
            \input{data/wfc_extraction}
            
            In Abbildung \ref{fig:extract_wrapping} ist der Ablauf dargestellt. Aus dem Beispiel werden die Umfelder ausgelesen. Die kann mit oder ohne \textit{Wrapping} passieren, wobei Wrapping bedeutet, dass wenn z.B. der rechte Rand überschritten wird, es zurück zum linken Rand und von da aus weiter geht. Dies kann separat für die vertikalen Ränder und die horizontalen Ränder erlaubt oder verboten werden. In der Abbildung wird vertikales Wrapping genutzt, ist das vom Nutzer nicht erwünscht so würden Umfelder, die den Rand des Beispiels überschreiten, einfach verworfen und nicht weiter verwendet. Die Zustände ergeben sich aus den einzigartigen Umfelder. Die Frequenz eines Umfelds gibt an wie oft es im Beispiel vorkommt. Sind mehrere Umfelder gleich, so hat der entsprechende Zustand einen höhere Frequenz. Aus der Gesamtanzahl an Zuständen und deren Frequenzen lässt sich die Wahrscheinlichkeit jedes Zustands berechen. Im Algorithmus wird dies beachtet, damit auch die globale Verteilung von Umfeldern in der Ausgabe der Verteilung im Beispiel ähnelt. Danach wird geprüft welche der gefundenen Umfelder überlappen. Es werden die Himmelrichtungen N, S, W und O geprüft und für später in einer Lookuptabelle gespeichert.
            
            \input{data/extract_wrapping/figure.tex}

    \section{Visualisierung}
        Die Ausgabe der Wave Function Collapse muss nicht direkt bildlich verwendet werden. Welche Bedeutung die Zellen und deren Zustände haben, ist dem Algorithmus egal. Dieser garantiert nur lokale Ähnlichkeit zum Beispiel. Im erfolgreiche Spiel \textit{Townscaper} \cite{stalberg_townscaper} von Oskar Stålberg wird Wave Function Collapse verwendet. In Abbildung \ref{fig:townscaper} sind einige Screenshots aus dem Spiel zu sehen.
        
        \input{data/townscaper/figure.tex}
        
        Hier kann die Spielerin aus Gebäuden eine Stadt bauen. Sie wählt dabei aber nicht die konkreten Gebäude aus, sondern legt nur fest, welche Art/Farbe an jeweiliger Stelle platziert werden soll. Das Spiel nutzt Wave Function Collapse, um die dementsprechend am besten passenden Gebäudeteile zu finden. Danach wird das gewählte Modell an den Knotenpunkt angepasst und mit Details wie Fensters oder Bänken ausgeschmückt.
        
        \input{data/townscaper_grid/figure.tex}
        
        Damit die Stadt nicht geradlinig verläuft, wird sie auf einer spezielle Art von Gitter gebaut. Abbildung \ref{fig:townscaper_grid} zeigt, wie die Teile, aus denen das Gitter besteht, generiert werden. Es ist zu erkennen, dass es auf einer Quadrilierung, aufbaut. Eine Quadrilierung ist ein Graph, dessen Kanten Vierecke bilden. Die sechseckigen Regionen werden im Spiel zusammengesetzt und an den Knoten kann die Spielerin Gebäude bauen. Die meisten Knotenpunkte haben vier Kanten, aber es gibt auch einzelne mit drei oder fünf Kanten. Im Spiel existieren für diese Arten von Knoten jeweils unterschiedliche Modelle von Gebäuden. Es müssen keine weiteren Modelle, für willkürlich viele Kanten an einem Knoten, erstellt werden, da dieser Prozess nur diese drei Arten von Knoten generiert. Es handelt sich also nicht um eine allgemeine Lösung, da die Beispielmodelle speziell für das genutzt Gitter erstellt wurden und nicht für anderen Art von Graphen funktionieren würden.

\input{3und4.tex}


\chapter{Ergebnisse und Diskussion}
    Dieses Kapitel präsentiert die erreichenten Ergebnisse. Zuerst werden die \at{@incomplete nach dem ausformulieren hier beschreiben.}. Danach werden die positiven wie auch negativen Effekte von Heat mittels Beispielen erklärt.
    
    \section{Übersicht und Auswertung}
        Im folgenden Abschnitt werden die Ausgaben des neuen Algorithmus dargestellt und erklärt. Abbildungen \ref{fig:results_1} und \ref{fig:results_2} zeigen eine Übersicht von Beispielen, Graphen und jeweils darauf generierte Ausgaben. In der ersten Reihe sind die Zellen der jeweiligen Graphen farbig dargestellt. Die erste Spalte zeigt die benutzen Beispielbilder. An drei Stellen fehlt die Ausgabe, da der Algorithmus innerhalb eines Zeitlimits von einer Minute keine Ausgabe generieren konnte. Zwar konnte der Algorithmus einem großem Teil der Zellen einen Zustand zuweisen, doch kam es immer wieder zu Widersprüchen.
        
        Zu den Graphen: \at{@incomplete ausführlicher und layout überdenken}
        \begin{itemize}
        \item (a) Quadratgitter mit Heat=1
        \item (b) Sechseckgitter mit Heat=2
        \item (c) Kreiförmige Anordnung der Punkte mit Heat=2
        \item (d) Zufällige Anordnung der Punkte, einmal mit Heat=2 in Spalte 4 und einmal mit Heat = 3 in Spalte 5
        \item (e) mehrere unterschiedlich große und gedrehte Gitter in einem Graph mit Heat = 2
        \end{itemize}
        
        \input{data/results/figure_1.tex}
        \input{data/results/figure_2.tex}
        
        
        \at{@incomplete beispiele nummerienen und genau sagen welche beispiel wo gemeint sind.}
        
        \begin{enumerate}
        \item erste reihe zeigt die Zellen, (a) Quadratgitter, (b) Sechseckgitter, (c) Kreisförmig, (d) Zufall, (e) eine Mischung aus unterschiedlichen gedrehten und angeordneten Gittern in einem Graphen
        \item Heat ist (a)=1, (b,c) = 2, (d) einmal 2 und einmal 3, (e) = 2. Wurde so gewählt, dass interessante Ausgaben entstehen
        \item (a) ausgaben sind äquivalent zu WFC nach Gumin, Gitter
        \item (b) ab hier Heat 2, bis auf kleine Makel sind es gute Ausgaben, Gitter
        \item (c) stellt uniforme verteilte Zellen dar, die nun nicht mehr auf einem Gitter liegen, 
        \item (d 2) erste beispiele konnten keine ergebnisse nach 1 minute laufzeit erzeugen. einzelne Ausgaben sind fast eintönig
        \item (d 3) vorherige fehlschläge und uninteressante ausgaben sind nun besser. im gegenzug sind vorher gute ausgaben nun schlechter(mehr fehler, weniger struktur erkennbar)
        \item (e) die einzelnen Gitterausschnitte sind gut, aber an den rändern wo zwei gitter angrenzen, entstehen schwer lösbar regionen. einige ausgaben verlieren hier an qualität
        \end{enumerate}
    
    % ////////////////////////////////////////////////
    
    \section{Heat und Ähnlichkeit}
        Dieser Abschnitt erklärt die Beziehung zwischen Heat und die erreichte Ähnlichkeit der Ausgabe zum Beispiel.
        
        \input{data/heat_more/figure.tex}
        
        Abbildung \ref{fig:heat_more} zeigt wie die Qualität der Ausgabe, bei steigender Heat, sinken kann. Der Graph ist hier ein Quadratgitter und kann somit schon bei einer Heat von 1 gute Ausgaben generieren. Mit jedem Schritt wird der jeder tatsächlichen Benachbarung eine größere Menge an Möglichkeiten gegeben. Es entstehen mehr fehlerhafte Regionen in der Ausgabe. Ab einer Heat von 5 kann der Algorithmus einer perfekt nach Osten laufenden Benachbarung nicht nur Nordosten und Südosten sondern auch Norden und Süden zuweisen, also zu einander entgegengesetzte Himmelrichtungen. Liegt z.B. eine Zelle östlich von einer anderen so könnten beide sich als südlich der anderen behandeln. Ab Heat=6 könnte jede Benachbarung auch als eine der entgegengesetze Himmelrichtungen behandelt werden. Schließlich verliert die Anordnung der Zellen bei Heat=8 komplett die Bedeutung. Zur Vollständigkeit sind hier Ausgaben mit hoher Heat dargestellt, in der Praxis sollte man Heat so gering wie möglich halten.
        
        
        
        \input{data/heat_hex/figure.tex}
        
        Abbildung \ref{fig:heat_hex} zeigt den Einfluss von Heat auf die Qualität der Ausgabe bei gleichem Beispiel und Graph. Das Beispiel kann auf dem Quadratgitter ohne weitere Probleme genutzt werden, siehe (b), während der Graph mit den Sechsecken bei geringer Heat uninteressante Ausgaben generiert, siehe (c).
        
        
        Eine intuitive Erklärung ist, dass die Linien im Beispiel stets nur eine Zelle breit sind. Im Graph können die horizontalen Linien generiert werden, weil die Sechsecke selbst horizontal in Reihen angeordnet sind, während es keine rein vertikalen Zellenspalten gibt. Jedes Sechseck hat zwei Nachbarzellen oberhalb und zwei unterhalb. Bei Heat=1 wird beiden Norden/Süden zugewiesen. Will der Algoritmus nun bei einer Zelle eine vertikalen Linie, also die Zustände die dieses Muster abbilden, platzieren, so müssen nun beide oberen Nachbarzellen auch eine Zustand, der eine vertikale Linie darstellt, erhalten. Hier kommt es zum Konflikt, da diese beiden Zellen horizontal in der gleichen Reihe liegen, es aber im Beispiel keine vertikalen Linien direkt nebeneinander gibt. Es kann also keine Zelle Teil einer vertikalen Linie sein. 
        
        Bei (d) können dennoch scheinbar vertikale Linien generiert werden, da nun die oberen Zellen jeweils als im Norden und imd Nordosten/-westen betrachtet werden. Ebenso können die horizontalen Nachbarn als im Westen oder im Süd-/Nord-westen behandelt werden. Soll eine Zelle nun Teil einer vertikalen Linie sein, kann nur eine der oberen Nachbarnzellen als im Norden behandelt werden und die andere als die jeweilige Diagonale. 
        
        Der Effekt von höherer Heat ist, das die Menge an möglichen Zuständen vergrößert wird, indem mehr Überlappungsregeln in Betracht gezogen werden. Dadurch ist es auch unwahrscheinlicher, dass für eine Zelle keine Zustände mehr möglich sind und ein Widerspruch entsteht. Gleichzeitig werden nun aber auch Ausgaben generiert, die eine tatsächlich geringere Ähnlickkeit zum Beispiel haben. So ist die Ausgabe in (c) zwar weniger interessant als die in (d), aber die horizontalen Linien und die grauen Flächen dazwischen passen exakt zur Teilen des Beispiels. Bei (d) werden auch vertikalen Linien generiert, aber diese haben knicke und sind eher zickzackartig als die Senkrechten des Beispiels. Eine Erhöhung der Heat verschlechtert die lokale Ähnlichkeit der Ausgabe zum Beispiel und verbessert die Wahrscheinlichkeit erfolgreich eine nicht triviale Lösung zu generieren.
        
        
        
        \input{data/heat_rotation/figure.tex}
        
        In Abbildung \ref{fig:heat_rotation} ist dargestellt, wie Heat auch als eine lokale Drehung des Gitters verstanden werden kann. In (b) ist das gewählte Beispiel (a) auf einem Quadratgitter ohne Drehung angewendet. Es können gute Ausgaben generiert werden. Dreht man das gesamte Quadratgitter nun um 22° so können die geraden Linien des Beispiels immernoch fehlerfrei platziert werden. Zwar sind die Zellen zueinander nicht mehr genau entlang der Himmelsrichtungen angeordnet, doch wird bei Heat=1 auf die nächste Richtung gerundet. Bei 8 Richtungen wird z.B. Osten von -22,5° bis 22,5° ausgewählt. Somit ist das Gitter bei (c) zwar optisch gedreht, aber kann genau wie das Gitter in (b) behandelt werden. Wird nun aber, wie in (d) noch weiter gedreht, so wird nun eine Benachbarung die vorher z.B. als Osten behandelt wurde nun als Nordosten behandelt. Der Effekt ist, dass die geradlinigen Muster des Beispiels nun (wie zuvor bei Abbildung \ref{fig:heat_hex}) nicht mehr platziert werden können. In der Ausgabe können nur noch flächenartige Muster vorkommen. In (e) ist zu sehen, dass dennoch gute Ausgaben generiert werden können, indem die Heat=2 gesetzt wird und jede Benachbarung nun z.B. als Nordosten und Osten behandelt wird. Der Algorithmus kann nun Ausgaben wie bei (c) generieren, da die Benachbarungen nun auch lokal wie die Benachbarungen aus (b) und (c) behandelt werden können. Heat kann also auch als eine lokale Drehung entgegen der tatsächlichen Ausrichtung des Gitters wirken. 
        
        Der selbe Effekt kommt auch bei unregelmäßigen Graphen zum Spiel. Hier existiert zwar kein Winkel um den man den gesamten Graphen drehen kann, um ein Quadratgitter zu erhalten. Aber da Heat lokal und von Nachbar zu Nachbar unabhängig wirkt, kann es als eine lokale Drehung oder Verzerrung verstanden werden. Es ist so, als könnte der Algorithmus die Zellen lokal so verschieben und verdrehen, dass einen breitere Menge an Lösungen möglich ist. Es muss dabei beachtet werden, dass der Algorithmus nicht gezielt arbeitet. Ist eine Graph bereits mit geringer Heat gut lösbar, so wird höhere Heat nicht unbedingt auch bessere Ergebnisse liefern. Es ist sogar wahrscheinlich, dass die Ausgabe schlechter wird da die höhere Heat ja auch zu Regionen in der Ausgabe führt die nicht im Beispiel existieren und den Einfluss der Richtung mindert.
        
        % ////////////////////////////////////////////////
        
    
    
    
    \section{Heat und Entropie}
        Im folgenden Abschnitt wird die Beziehung zwischen Heat und Entropie genauer untersucht.
        
        
        
        \input{data/heat_entropy/figure.tex}
        
        In Abbildung \ref{fig:heat_entropy} ist dargestellt, wie höhere Heat die Entropie von Zellen über den Verlauf des Algorithmus beeinflusst. Die Zellen sind jeweils nach einem und nach fünf Schritten dargestellt. Der Algorithmus hat jeweils anderen Zellen und jeweils andere Zustände zufällig ausgewählt, doch der Trend ist erkennbar. Eine kollabierte Zelle beschränkt die Menge an möglichen Zuständen ihrer Nachbarn und verringert somit deren Entropie. Dies kann soweit gehen, dass die Nachbarzellen auch nur noch einen möglichen Zustand haben und von selbst kollabieren. Bei geringer Heat kann sie auch auf entfernte Zellen einen großen Einfluss haben. Wird die Heat erhöht, so wird der Einflussbereich einzelner Zellen immer kleiner, weil jede Zelle weniger Einfluss auf ihre Nachbarn hat, und diese Nachbar wiederum ihre Nachbar weniger beschränken. Es bedarf mehr Schritte um die selbe Anzahl an Zellen zu kollabieren.
        
        
        
        \input{data/heat_plot/figure.tex}
        
        Abbildung \ref{fig:heat_plot} zeigt die Beziehung zwischen der Heat und der Entropie aller Zelle. Die Gesamtentropie fällt stetig, da der Algorithmus in jedem Schritt eine Zelle kollabiert, wodurch diese nun eine Entropie von 0 hat. Gleichzeitig beeinflusst diese Zelle auch ihre Nachbarn und die wiederum deren Nachbarn indem nun bestimmte Zustände für diese nicht mehr möglich sind. Dabei kann es sein, dass anderen Zellen auch in einen Zustand einzigen Zustand kollabieren, da alle anderen Zustände unmöglich geworden sind. Die Entropie der Nachbarn wird also auch verringert. Schließlich hat der Algorithmus alle Zellen kollabiert und die Gesamtentropie fällt auf 0; die Ausgabe ist fertig generiert. 
        
        Im Diagramm sind nur die erfolgreichen Schritte dargestellt. Kam es zu einem Widerspruch und Backtracking, so wurden die Daten fehlgeschlagenen Schritte überschrieben. Im Verlauf des Algorithmus mit Backtracking würde die Gesamtentropie scheinbar steigen, doch ein Schritt mit geringer Entropie kann niemals einen mit zu einem Schritt mit höherer Entropie führen.
        
        Im Diagramm sind mehrere Verläufe dargestellt, jeweils mit gleichem Beispielbild und Graphen, aber mit unterschiedlicher Heat. Es ist zu erkennen, dass die Gesamtentropie bei höherer Heat langsamer abfällt als bei kleinerer Heat. Auch unterschieden sich die Verläufe in der Steilheit. Bei niedriger Heat gibt es immer wieder Schritte die die Entropie stark reduzieren. Dabei handelt es sich um eine Zelle, dessen gewählter Zustand eine große Menge anderer Zellen beeinflusst hat. Währendessen tretten solche Fälle bei hoher Heat selten bis garnicht auf. Die meisten Schritte verringern die Entropie gleichstark. Grund dafür ist, dass Heat den Nachbarn einer Zelle mehr Überlappungsregeln zur Verfügung stellt. Es genpgt nur eine valide Regel, damit ein Zustand möglich ist. Somit haben Nachbarzellen länger mehr mögliche Zustände. Gleichzeitig haben aber auch die Nachbarn der Nachbarzellen nun auch mehr Kombinationsmöglichkeiten, von denen wieder nur mindestens eine passen muss. Bei höherer Heat vermindert sich der Einflussbereich einer kollabierten Zelle, bis sie nur noch ihre direkten Nachbarzellen beeinflusst. 
        
        Es ist auch zu erkennen, dass die Verläufe mit Heat 6, 7 und 8 beinahe identisch sind. Ab einem gewissen Punkt, sind Zellen so unabhängig von einander, dass höhere Heat keinen Unterschied mehr macht. Das Limit dieses Verhalten würde dann erreicht werden, wenn jede Zelle tatsächlich unabhängig von allen anderen Zellen ist. Dann kann der Algorithmus in jedem Schritt nur einen Zelle kollabieren und keine der anderen Zellen damit beschränken. Die Entropie fällt dann mit einer konstanten Rate und es müssen genauso viele Schritte wie es Zellen im Graphen gibt geschehen.






\chapter{Zusammenfassung und Ausblick}
    Dieses Kapitel bietet einen Rückblick auf die erfolgreiche Erweiterung des Wave Function Collapse Algorithmus. Auch werden noch bestehende Schwachstellen der präsentierten Methodik erklärt. Diese könnten als Ansatz für weiterführende Forschung und Weiterentwicklung des Algorithmus dienen.
    
    \section{Fazit}
        Diese Arbeit zeigt, wie der Wave Function Collapse Algorithmus erweitert werden kann, damit die generierten Ausgaben nicht nur auf Gittern sondern auch auf, vom Nutzer gegebenen, Graphen geschehen kann. Dem Algorithmus muss hierfür lediglich ein Graph gegeben. Die Erfolgschance und Qualität der Ausgabe hängt dabei von den Eingenschaften des verwendeten Beispiels und des Graphen ab. Kommt es dazu, dass der Algorithmus nur weniger interessant Ausgaben generieren kann, so kann der Nutzer mittels des neu eingeführtem Konzept, der Heat, dem entgegenwirken, indem die erzielte Ähnlichkeit der Ausgabe zum Beispiel abgeschwächt wird.
    
        Am besten funktioniert der Algorithmus auf Graphen mit relativ uniformen Verteilungen von Zellen. Hierbei muss es sich nicht nur um ein einfaches Gitter handeln. Der Graph kann auch eine Zusammensetzung aus unterschiedlichen Arten von regelmäßigen Graphen sein, welche mittels des dargestellten Algorithmus zur Generierung von Graphen verbunden werden können. Je nach Beispiel können auch komplexere Graphen gute Ergebnisse liefern, doch kann es hier auch oft zu Fehlschlägen kommen, da nur eine Zelle in einem Graphen genügt um einen Widerspruch auszulösen. Um die Erfolgschancen einer Generierung zu verbessern, wurde präsentiert, wie der Algorithmus angepasst werden kann, um Backtracking zu erlauben. Dadurch kann bei einem Widerspruch ein Großteil der Arbeit erhalten bleiben, indem zu einem validen Punkt zurückgegangen wird, um von dort aus weiterzuarbeiten.
    
    
    
    \section{Beschränkungen}
        \at{@incomplete fragezeichen umformulieren oder auslassen und einleitung anpassen}
        \at{@incomplete nicht planare Graphen}
        
        \begin{enumerate}
        \item Diese Arbeit hat den Algorithmus nur in 2D betrachtet. Währenddessen wurden Model Synthesis und Wave Function Collapse schon in 3D angewandt. Kann diese Erweiterung des Wave Function Collapse auch auf dreidimensionale Graphen angewandt werden?
        \item Die Ausgabe kann nun auf einem Graphen geschehen, während das Beispiel immer noch auf einem Gitter liegt. Die tatsächlichen Richtungen in der Ausgabe werden auf die extrahierten Richtungen im Beispiel gerundet. Könnten Beispiele dann auch auf Graphen basieren, welche nicht direkt zum Graph der Ausgabe passen müssen?
        \item In dieser Arbeit wird der Graph für die Ausgabe erst generiert und dann werden dessen Zellen vom Algorithmus bearbeitet. Kann der Graph stattdessen dynamisch während der Generierung angepasst oder gänzlich erst dann erstellt werden, so dass neue Zellen so platziert werden, dass die Ähnlichkeit zum Beispiel oder andere gewünschte Beschränkungen auf die Ausgabe erfüllt werden?
        \item Es besteht eine Beziehung zwischen den Mustern eines Beispiels, der Struktur des Graphens und der gewählten Heat, die die Erfolgsquote und die Qualität der Ausgaben beeinflusst. So lassen sich bestimmte Muster nur schlecht auf bestimmte Regionen des Graphen anwenden oder führen oft zu Widersprüchen. Können solche Muster und Regionen vorzeitig erkannt werden?
        \item Für diese Arbeit wird Heat immer als globaler Parameter der gesamten Ausgabe behandelt. Sind die Zellen des Graphen größtenteils uniform, so kann ein optimaler Wert für eine globale Heat gefunden werden. Unregelmäßigen Graphen hingegen enthalten Regionen die besser mit wenig Heat und Regionen die besser mit hoher Heat gelöst werden können. Kann der Algorithmus erweitert werden, so dass Heat entsprechend der Struktur und Anordnung lokal angepasst wird?
        \item Desweiteren wird Heat vor Beginn der Generierung festgelegt. Wie kann diese stattdessen im Algorithmus mittels Heuristiken automatisch angepasst werden, wenn z.B. ein Widerspruch erreicht wurde?
        \end{enumerate}






% ////////////////////////////////////////////////
\bibliographystyle{plain}
\bibliography{Literatur}



% ////////////////////////////////////////////////
\chapter*{Verwendetet Hilfsmittel}
\begin{table}[h]
    \centering
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{|p{.33\linewidth}|p{.64\linewidth}|} 
        \hline \textbf{Hilfsmittel/Programm} & \textbf{Verwendung innerhalb der Arbeit}       \\
        \hline Visual Studio Code           & Code- und Texteditor                            \\
        \hline Odin-Programmiersprache      & Entwicklung der Anwendung                       \\
        \hline dearImgui                    & UI-Bibliothek für die Anwendung                 \\
        \hline raddebugger                  & Debugging der Anwendung                         \\
        \hline Git                          & Versionsverwaltung                              \\
        \hline Github                       & Backup und Synchronisierung der Arbeit          \\
        \hline Google Scholar               & Recherche wissenschaftlicher Literatur          \\
        \hline duck.ai, ChatGPT             & Brainstorming und Nachschlagen von Latex Syntax \\
        \hline \end{tabular}
    \end{table}
    


% ////////////////////////////////////////////////
\chapter*{Selbstständigkeitserklärung}

Durch meine Unterschrift erkläre ich, dass ich die vorliegende Arbeit mit dem Titel: \textit{Wave Function Collapse auf Graphen} selbständig verfasst und in gleicher oder ähnlicher Fassung noch nicht in einem anderen Studiengang als Prüfungsleistung vorgelegt habe. Ich habe alle von mir genutzten Hilfsmittel und Quellen, einschließlich generativer Modelle/KI angegeben und die den verwendeten Quellen und Hilfsmitteln wörtlich oder sinngemäß entnommenen Stellen in Form von Zitaten kenntlich gemacht. Darüber hinaus habe ich keine Hilfsmittel verwendet.

\vspace{3cm}

\noindent
\begin{minipage}[c]{5cm}
    \centering \hrulefill \\
    Ort, Datum
\end{minipage}
\hfill
\begin{minipage}[c]{7cm}
    \centering \hrulefill \\
    Unterschrift
\end{minipage}

\end{document}