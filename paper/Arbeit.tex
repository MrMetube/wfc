\documentclass[12pt,a4paper,oneside]{scrreprt}

\usepackage[T1]{fontenc}    % bessere Akzente auf äöü
\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} % Deutsche Begriffe
\usepackage{lmodern}        % bessere Schriftart

\usepackage{hyperref}                          % clickable links
\usepackage{amsmath, amssymb}                  % mathe formeln
\usepackage{graphicx, caption, subcaption}     % for figures and subfigures
\captionsetup[figure]{font=small,format=plain} % figure caption style

\usepackage{float}                             % enforce figure placement
\usepackage{setspace}                          % line doublespacing...
\usepackage{geometry}
\geometry{left=3.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

\usepackage{algorithm}
\usepackage{algorithmic}
\makeatletter \renewcommand{\ALG@name}{Algorithmus} \makeatother

% ////////////////////////////////////////////////

% 
% @important
% 
% Vor Abgabe löschen:
% 

\usepackage{xcolor}
\definecolor{mred}{HTML}{fe163d}
\definecolor{mgreen}{HTML}{009052}
\definecolor{mblue}{HTML}{586076}
\DeclareRobustCommand{\@todo(viktor):}[1]{
    \textcolor{mred}{@todo:} \textcolor{mred}{#1}
} 
\DeclareRobustCommand{\at}[1]{
    \textcolor{mgreen}{#1}
}



% ////////////////////////////////////////////////



\begin{document}

% 
% @important
% Vor Abgabe:
% 

\@todo(viktor):{pdf in git laden}

\@todo(viktor):{Abbildungen Anordung verbessern in Kapitel 5}

% 
% @important
% Abgabe:
% 
\@todo(viktor):{Die Selbstständigkeitserklärung unterschreiben}

\@todo(viktor):{Die PDF an:
    \\stefan.schlechtweg@hs-anhalt.de
    \\anika.gross@hs-anhalt.de
    \\axel.schneider@hs-anhalt.de
    \\pruefungsamt-koethen@hs-anhalt.de
}

\input{1und2.tex}

\input{3und4.tex}


\chapter{Ergebnisse und Diskussion}
    Dieses Kapitel präsentiert die erreichenten Ergebnisse. Zuerst werden die \at{@incomplete nach dem ausformulieren hier beschreiben.}. Danach werden die positiven wie auch negativen Effekte von Heat mittels Beispielen erklärt.
    
    \section{Übersicht und Auswertung}
        Im folgenden Abschnitt werden die Ausgaben des neuen Algorithmus dargestellt und erklärt. Abbildungen \ref{fig:results_1} und \ref{fig:results_2} zeigen eine Übersicht von Beispielen, Graphen und jeweils darauf generierte Ausgaben. In der ersten Reihe sind die Zellen der jeweiligen Graphen farbig dargestellt. Die erste Spalte zeigt die benutzen Beispielbilder. An drei Stellen fehlt die Ausgabe, da der Algorithmus innerhalb eines Zeitlimits von einer Minute keine Ausgabe generieren konnte. Zwar konnte der Algorithmus einem großem Teil der Zellen einen Zustand zuweisen, doch kam es immer wieder zu Widersprüchen.
        
        Zu den Graphen: \at{@incomplete ausführlicher und layout überdenken}
        \begin{itemize}
        \item (a) Quadratgitter mit Heat=1
        \item (b) Sechseckgitter mit Heat=2
        \item (c) Kreiförmige Anordnung der Punkte mit Heat=2
        \item (d) Zufällige Anordnung der Punkte, einmal mit Heat=2 in Spalte 4 und einmal mit Heat = 3 in Spalte 5
        \item (e) mehrere unterschiedlich große und gedrehte Gitter in einem Graph mit Heat = 2
        \end{itemize}
        
        \input{data/results/figure_1.tex}
        \input{data/results/figure_2.tex}
        
        
        \at{@incomplete beispiele nummerienen und genau sagen welche beispiel wo gemeint sind.}
        
        \begin{enumerate}
        \item erste reihe zeigt die Zellen, (a) Quadratgitter, (b) Sechseckgitter, (c) Kreisförmig, (d) Zufall, (e) eine Mischung aus unterschiedlichen gedrehten und angeordneten Gittern in einem Graphen
        \item Heat ist (a)=1, (b,c) = 2, (d) einmal 2 und einmal 3, (e) = 2. Wurde so gewählt, dass interessante Ausgaben entstehen
        \item (a) ausgaben sind äquivalent zu WFC nach Gumin, Gitter
        \item (b) ab hier Heat 2, bis auf kleine Makel sind es gute Ausgaben, Gitter
        \item (c) stellt uniforme verteilte Zellen dar, die nun nicht mehr auf einem Gitter liegen, 
        \item (d 2) erste beispiele konnten keine ergebnisse nach 1 minute laufzeit erzeugen. einzelne Ausgaben sind fast eintönig
        \item (d 3) vorherige fehlschläge und uninteressante ausgaben sind nun besser. im gegenzug sind vorher gute ausgaben nun schlechter(mehr fehler, weniger struktur erkennbar)
        \item (e) die einzelnen Gitterausschnitte sind gut, aber an den rändern wo zwei gitter angrenzen, entstehen schwer lösbar regionen. einige ausgaben verlieren hier an qualität
        \end{enumerate}
    
    % ////////////////////////////////////////////////
    
    \section{Heat und Ähnlichkeit}
        Dieser Abschnitt erklärt die Beziehung zwischen Heat und die erreichte Ähnlichkeit der Ausgabe zum Beispiel.
        
        \input{data/heat_more/figure.tex}
        
        Abbildung \ref{fig:heat_more} zeigt wie die Qualität der Ausgabe, bei steigender Heat, sinken kann. Der Graph ist hier ein Quadratgitter und kann somit schon bei einer Heat von 1 gute Ausgaben generieren. Mit jedem Schritt wird der jeder tatsächlichen Benachbarung eine größere Menge an Möglichkeiten gegeben. Es entstehen mehr fehlerhafte Regionen in der Ausgabe. Ab einer Heat von 5 kann der Algorithmus einer perfekt nach Osten laufenden Benachbarung nicht nur Nordosten und Südosten sondern auch Norden und Süden zuweisen, also zu einander entgegengesetzte Himmelrichtungen. Liegt z.B. eine Zelle östlich von einer anderen so könnten beide sich als südlich der anderen behandeln. Ab Heat=6 könnte jede Benachbarung auch als eine der entgegengesetze Himmelrichtungen behandelt werden. Schließlich verliert die Anordnung der Zellen bei Heat=8 komplett die Bedeutung. Zur Vollständigkeit sind hier Ausgaben mit hoher Heat dargestellt, in der Praxis sollte man Heat so gering wie möglich halten.
        
        
        
        \input{data/heat_hex/figure.tex}
        
        Abbildung \ref{fig:heat_hex} zeigt den Einfluss von Heat auf die Qualität der Ausgabe bei gleichem Beispiel und Graph. Das Beispiel kann auf dem Quadratgitter ohne weitere Probleme genutzt werden, siehe (b), während der Graph mit den Sechsecken bei geringer Heat uninteressante Ausgaben generiert, siehe (c).
        
        
        Eine intuitive Erklärung ist, dass die Linien im Beispiel stets nur eine Zelle breit sind. Im Graph können die horizontalen Linien generiert werden, weil die Sechsecke selbst horizontal in Reihen angeordnet sind, während es keine rein vertikalen Zellenspalten gibt. Jedes Sechseck hat zwei Nachbarzellen oberhalb und zwei unterhalb. Bei Heat=1 wird beiden Norden/Süden zugewiesen. Will der Algoritmus nun bei einer Zelle eine vertikalen Linie, also die Zustände die dieses Muster abbilden, platzieren, so müssen nun beide oberen Nachbarzellen auch eine Zustand, der eine vertikale Linie darstellt, erhalten. Hier kommt es zum Konflikt, da diese beiden Zellen horizontal in der gleichen Reihe liegen, es aber im Beispiel keine vertikalen Linien direkt nebeneinander gibt. Es kann also keine Zelle Teil einer vertikalen Linie sein. 
        
        Bei (d) können dennoch scheinbar vertikale Linien generiert werden, da nun die oberen Zellen jeweils als im Norden und imd Nordosten/-westen betrachtet werden. Ebenso können die horizontalen Nachbarn als im Westen oder im Süd-/Nord-westen behandelt werden. Soll eine Zelle nun Teil einer vertikalen Linie sein, kann nur eine der oberen Nachbarnzellen als im Norden behandelt werden und die andere als die jeweilige Diagonale. 
        
        Der Effekt von höherer Heat ist, das die Menge an möglichen Zuständen vergrößert wird, indem mehr Überlappungsregeln in Betracht gezogen werden. Dadurch ist es auch unwahrscheinlicher, dass für eine Zelle keine Zustände mehr möglich sind und ein Widerspruch entsteht. Gleichzeitig werden nun aber auch Ausgaben generiert, die eine tatsächlich geringere Ähnlickkeit zum Beispiel haben. So ist die Ausgabe in (c) zwar weniger interessant als die in (d), aber die horizontalen Linien und die grauen Flächen dazwischen passen exakt zur Teilen des Beispiels. Bei (d) werden auch vertikalen Linien generiert, aber diese haben knicke und sind eher zickzackartig als die Senkrechten des Beispiels. Eine Erhöhung der Heat verschlechtert die lokale Ähnlichkeit der Ausgabe zum Beispiel und verbessert die Wahrscheinlichkeit erfolgreich eine nicht triviale Lösung zu generieren.
        
        
        
        \input{data/heat_rotation/figure.tex}
        
        In Abbildung \ref{fig:heat_rotation} ist dargestellt, wie Heat auch als eine lokale Drehung des Gitters verstanden werden kann. In (b) ist das gewählte Beispiel (a) auf einem Quadratgitter ohne Drehung angewendet. Es können gute Ausgaben generiert werden. Dreht man das gesamte Quadratgitter nun um 22° so können die geraden Linien des Beispiels immernoch fehlerfrei platziert werden. Zwar sind die Zellen zueinander nicht mehr genau entlang der Himmelsrichtungen angeordnet, doch wird bei Heat=1 auf die nächste Richtung gerundet. Bei 8 Richtungen wird z.B. Osten von -22,5° bis 22,5° ausgewählt. Somit ist das Gitter bei (c) zwar optisch gedreht, aber kann genau wie das Gitter in (b) behandelt werden. Wird nun aber, wie in (d) noch weiter gedreht, so wird nun eine Benachbarung die vorher z.B. als Osten behandelt wurde nun als Nordosten behandelt. Der Effekt ist, dass die geradlinigen Muster des Beispiels nun (wie zuvor bei Abbildung \ref{fig:heat_hex}) nicht mehr platziert werden können. In der Ausgabe können nur noch flächenartige Muster vorkommen. In (e) ist zu sehen, dass dennoch gute Ausgaben generiert werden können, indem die Heat=2 gesetzt wird und jede Benachbarung nun z.B. als Nordosten und Osten behandelt wird. Der Algorithmus kann nun Ausgaben wie bei (c) generieren, da die Benachbarungen nun auch lokal wie die Benachbarungen aus (b) und (c) behandelt werden können. Heat kann also auch als eine lokale Drehung entgegen der tatsächlichen Ausrichtung des Gitters wirken. 
        
        Der selbe Effekt kommt auch bei unregelmäßigen Graphen zum Spiel. Hier existiert zwar kein Winkel um den man den gesamten Graphen drehen kann, um ein Quadratgitter zu erhalten. Aber da Heat lokal und von Nachbar zu Nachbar unabhängig wirkt, kann es als eine lokale Drehung oder Verzerrung verstanden werden. Es ist so, als könnte der Algorithmus die Zellen lokal so verschieben und verdrehen, dass einen breitere Menge an Lösungen möglich ist. Es muss dabei beachtet werden, dass der Algorithmus nicht gezielt arbeitet. Ist eine Graph bereits mit geringer Heat gut lösbar, so wird höhere Heat nicht unbedingt auch bessere Ergebnisse liefern. Es ist sogar wahrscheinlich, dass die Ausgabe schlechter wird da die höhere Heat ja auch zu Regionen in der Ausgabe führt die nicht im Beispiel existieren und den Einfluss der Richtung mindert.
        
        % ////////////////////////////////////////////////
        
    
    
    
    \section{Heat und Entropie}
        Im folgenden Abschnitt wird die Beziehung zwischen Heat und Entropie genauer untersucht.
        
        
        
        \input{data/heat_entropy/figure.tex}
        
        In Abbildung \ref{fig:heat_entropy} ist dargestellt, wie höhere Heat die Entropie von Zellen über den Verlauf des Algorithmus beeinflusst. Die Zellen sind jeweils nach einem und nach fünf Schritten dargestellt. Der Algorithmus hat jeweils anderen Zellen und jeweils andere Zustände zufällig ausgewählt, doch der Trend ist erkennbar. Eine kollabierte Zelle beschränkt die Menge an möglichen Zuständen ihrer Nachbarn und verringert somit deren Entropie. Dies kann soweit gehen, dass die Nachbarzellen auch nur noch einen möglichen Zustand haben und von selbst kollabieren. Bei geringer Heat kann sie auch auf entfernte Zellen einen großen Einfluss haben. Wird die Heat erhöht, so wird der Einflussbereich einzelner Zellen immer kleiner, weil jede Zelle weniger Einfluss auf ihre Nachbarn hat, und diese Nachbar wiederum ihre Nachbar weniger beschränken. Es bedarf mehr Schritte um die selbe Anzahl an Zellen zu kollabieren.
        
        
        
        \input{data/heat_plot/figure.tex}
        
        Abbildung \ref{fig:heat_plot} zeigt die Beziehung zwischen der Heat und der Entropie aller Zelle. Die Gesamtentropie fällt stetig, da der Algorithmus in jedem Schritt eine Zelle kollabiert, wodurch diese nun eine Entropie von 0 hat. Gleichzeitig beeinflusst diese Zelle auch ihre Nachbarn und die wiederum deren Nachbarn indem nun bestimmte Zustände für diese nicht mehr möglich sind. Dabei kann es sein, dass anderen Zellen auch in einen Zustand einzigen Zustand kollabieren, da alle anderen Zustände unmöglich geworden sind. Die Entropie der Nachbarn wird also auch verringert. Schließlich hat der Algorithmus alle Zellen kollabiert und die Gesamtentropie fällt auf 0; die Ausgabe ist fertig generiert. 
        
        Im Diagramm sind nur die erfolgreichen Schritte dargestellt. Kam es zu einem Widerspruch und Backtracking, so wurden die Daten fehlgeschlagenen Schritte überschrieben. Im Verlauf des Algorithmus mit Backtracking würde die Gesamtentropie scheinbar steigen, doch ein Schritt mit geringer Entropie kann niemals einen mit zu einem Schritt mit höherer Entropie führen.
        
        Im Diagramm sind mehrere Verläufe dargestellt, jeweils mit gleichem Beispielbild und Graphen, aber mit unterschiedlicher Heat. Es ist zu erkennen, dass die Gesamtentropie bei höherer Heat langsamer abfällt als bei kleinerer Heat. Auch unterschieden sich die Verläufe in der Steilheit. Bei niedriger Heat gibt es immer wieder Schritte die die Entropie stark reduzieren. Dabei handelt es sich um eine Zelle, dessen gewählter Zustand eine große Menge anderer Zellen beeinflusst hat. Währendessen tretten solche Fälle bei hoher Heat selten bis garnicht auf. Die meisten Schritte verringern die Entropie gleichstark. Grund dafür ist, dass Heat den Nachbarn einer Zelle mehr Überlappungsregeln zur Verfügung stellt. Es genpgt nur eine valide Regel, damit ein Zustand möglich ist. Somit haben Nachbarzellen länger mehr mögliche Zustände. Gleichzeitig haben aber auch die Nachbarn der Nachbarzellen nun auch mehr Kombinationsmöglichkeiten, von denen wieder nur mindestens eine passen muss. Bei höherer Heat vermindert sich der Einflussbereich einer kollabierten Zelle, bis sie nur noch ihre direkten Nachbarzellen beeinflusst. 
        
        Es ist auch zu erkennen, dass die Verläufe mit Heat 6, 7 und 8 beinahe identisch sind. Ab einem gewissen Punkt, sind Zellen so unabhängig von einander, dass höhere Heat keinen Unterschied mehr macht. Das Limit dieses Verhalten würde dann erreicht werden, wenn jede Zelle tatsächlich unabhängig von allen anderen Zellen ist. Dann kann der Algorithmus in jedem Schritt nur einen Zelle kollabieren und keine der anderen Zellen damit beschränken. Die Entropie fällt dann mit einer konstanten Rate und es müssen genauso viele Schritte wie es Zellen im Graphen gibt geschehen.






\chapter{Zusammenfassung und Ausblick}
    Dieses Kapitel bietet einen Rückblick auf die erfolgreiche Erweiterung des Wave Function Collapse Algorithmus. Auch werden noch bestehende Schwachstellen der präsentierten Methodik erklärt. Diese könnten als Ansatz für weiterführende Forschung und Weiterentwicklung des Algorithmus dienen.
    
    \section{Fazit}
        Diese Arbeit zeigt, wie der Wave Function Collapse Algorithmus erweitert werden kann, damit die generierten Ausgaben nicht nur auf Gittern sondern auch auf, vom Nutzer gegebenen, Graphen geschehen kann. Dem Algorithmus muss hierfür lediglich ein Graph gegeben. Die Erfolgschance und Qualität der Ausgabe hängt dabei von den Eingenschaften des verwendeten Beispiels und des Graphen ab. Kommt es dazu, dass der Algorithmus nur weniger interessant Ausgaben generieren kann, so kann der Nutzer mittels des neu eingeführtem Konzept, der Heat, dem entgegenwirken, indem die erzielte Ähnlichkeit der Ausgabe zum Beispiel abgeschwächt wird.
    
        Am besten funktioniert der Algorithmus auf Graphen mit relativ uniformen Verteilungen von Zellen. Hierbei muss es sich nicht nur um ein einfaches Gitter handeln. Der Graph kann auch eine Zusammensetzung aus unterschiedlichen Arten von regelmäßigen Graphen sein, welche mittels des dargestellten Algorithmus zur Generierung von Graphen verbunden werden können. Je nach Beispiel können auch komplexere Graphen gute Ergebnisse liefern, doch kann es hier auch oft zu Fehlschlägen kommen, da nur eine Zelle in einem Graphen genügt um einen Widerspruch auszulösen. Um die Erfolgschancen einer Generierung zu verbessern, wurde präsentiert, wie der Algorithmus angepasst werden kann, um Backtracking zu erlauben. Dadurch kann bei einem Widerspruch ein Großteil der Arbeit erhalten bleiben, indem zu einem validen Punkt zurückgegangen wird, um von dort aus weiterzuarbeiten.
    
    
    
    \section{Beschränkungen}
        In diesem Abschnitt wird kurz auf die wichtigsten Beschränkungen des erweiterten Algorithmus und der Herangehensweise und Verwendung dessen eingegangen.
        
        Diese Arbeit hat ausschließlich mit zweidimensionalen Beispielen gearbeitet, obwohl Model Synthesis und Wave Function Collapse auch in 3D angewendet wurden. 
        
        Die Graphen wurden stets vor Beginn der Generierung erstellt. Der Algorithmus zur Generierung der Graphen erstellt dabei immer eine Triangulierung, also sind alle Zellen stark vernetzt mit naheliegenden Zellen. Dies bietete sich an, da Wave Function Collapse lokale Regeln aus den Beispielen auf die Ausgabe anwendet. Andererseits wäre es möglich auch anderen Arten von Graphen zu verwenden. So könnten relativ zur Triangulierung Kanten entfernt werden um Diskontinuitäten in der Ausgabe zu erzeugen. Andersherum könnten neue Kanten eingefügt werden, um entfernte Zellen miteinander zu verbinden, was in der Ausgabe zu brückenähnlichen Effekten führen könnte. 
        
        Desweiteren wurden uniform verteilte Zellen präferiert, da diese Erfahrungsgemäß eine bessere Erfolgsquote hatten. Dies hängt direkt damit zusammen, dass Heat als globaler Wert für alle Zellen genutzt wurde. Unregelmäßigere Anordnungen enthalten eher Zellen mit extremer Anzahl an Nachbarn oder anderen außergewöhnlichen Eigenschaften, wobei Zellen mit vielen Nachbarn mehr eingeschränkt sind und dadurch häufiger Widersprüche auslösen können. Haben alle Zellen relativ ähnliche Eigenschaften, so lässt sich leichter ein guter Heat-Wert für sie finden.
        
        Letztlich wurde die Heat immer manuell vom Nutzer vor Beginn festgelegt. Wurde sie während der Generierung angepasst, so verwarf der Algorithmus alle Arbeit und startete neu. Es wäre aber möglich, die Heat während des Ablaufs manuell oder automatisch z.B. mittels Heuristiken anzupassen und weiterzuarbeiten.
        


% ////////////////////////////////////////////////
\bibliographystyle{plain}
\bibliography{Literatur}



% ////////////////////////////////////////////////
\chapter*{Verwendetet Hilfsmittel}
\begin{table}[h]
    \centering
    \renewcommand{\arraystretch}{1.25}
    \begin{tabular}{|p{.33\linewidth}|p{.64\linewidth}|} 
        \hline \textbf{Hilfsmittel/Programm} & \textbf{Verwendung innerhalb der Arbeit}       \\
        \hline Visual Studio Code           & Code- und Texteditor                            \\
        \hline Odin-Programmiersprache      & Entwicklung der Anwendung                       \\
        \hline dearImgui                    & UI-Bibliothek für die Anwendung                 \\
        \hline raddebugger                  & Debugging der Anwendung                         \\
        \hline Git                          & Versionsverwaltung                              \\
        \hline Github                       & Backup und Synchronisierung der Arbeit          \\
        \hline Google Scholar               & Recherche wissenschaftlicher Literatur          \\
        \hline duck.ai, ChatGPT             & Brainstorming und Nachschlagen von Latex Syntax \\
        \hline \end{tabular}
    \end{table}
    


% ////////////////////////////////////////////////
\chapter*{Selbstständigkeitserklärung}

Durch meine Unterschrift erkläre ich, dass ich die vorliegende Arbeit mit dem Titel: \textit{Wave Function Collapse auf Graphen} selbständig verfasst und in gleicher oder ähnlicher Fassung noch nicht in einem anderen Studiengang als Prüfungsleistung vorgelegt habe. Ich habe alle von mir genutzten Hilfsmittel und Quellen, einschließlich generativer Modelle/KI angegeben und die den verwendeten Quellen und Hilfsmitteln wörtlich oder sinngemäß entnommenen Stellen in Form von Zitaten kenntlich gemacht. Darüber hinaus habe ich keine Hilfsmittel verwendet.

\vspace{3cm}

\noindent
\begin{minipage}[c]{5cm}
    \centering \hrulefill \\
    Ort, Datum
\end{minipage}
\hfill
\begin{minipage}[c]{7cm}
    \centering \hrulefill \\
    Unterschrift
\end{minipage}

\end{document}