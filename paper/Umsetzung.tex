\section{State Extraction}
\begin{itemize}
    \item Bei der Extrahierung nutze ich die Methode mit Überlappung, d.h. von jedem Pixel in dem Eingabebild wird jeweils ein N-mal-N großes Fenster betrachtet. 
    \item Je nach Eingabebild kann ein Wrapping an den Kanten gewünscht oder unerwünscht sein. Ist es erlaubt, dann geht bei Pixeln die Näher im Rand sind als N Pixel das betrachtete Fenster über den Bildrand hinaus und zurück zur gegenüberliegeden Kante und von da weiter. So als wäre das Eingabebild an dieser Kante nocheinmal angelegt. Ist es nicht erlaubt, so werden für solche Pixel keine Fenster betrachtet.
    \item Ich habe die gesamte Zeit stets N = 3 benutzt. Meine Auswahl an Eingabebildern wurden dafür konzipiert und geben damit die ''besten`` Ergebnisse.
    \item Wenn zwei Fenster exakt die gleichen Farbwerte haben, dann werten wir sie als ein und den selben und notieren dass der Zustand eine höhere Frequenz in der Eingabe hat. Diese Frequenz wird bei der späteren Generierung mit in betracht gezogen.
    \item Der mittlere Pixel stellt den Farbwert dieses Zustands dar. 
    \item Mit den Pixeln drum herum errechnen wir, welche dieser Fenster nun überlappen können.
    \item @todo(viktor): 8 richtungen
\end{itemize}

\section{Overlap Lookup Table}
\begin{itemize}
    \item Für den Wave Function Collapse muss ich später prüfen, ob ein Zustand neben einem (oder mindestens einen von vielen) Zuständen seien darf.
    \item Hierfür erstelle ich eine Tabelle mit drei Axen. Die ersten beiden sind die zu vergleichenden Zustände, die dritte bestimmt die Himmelsrichtung entlang der ich diese vergleiche.
    \item Jeder Eintrag sagt mir nun, ob ein Zustand A neben einem Zustand B der in Richtung D von A aus liegt in der Eingabe existiert hat und somit möglich ist.
    \item Da die Überlappung eine symmetrische Eigenschaft ist, ist auch die Tabelle symmetrisch. Man könnte also nur halb so viele Einträge speichern solange man dies beim auslesen bedenkt. In meiner Implementierung habe ich diese Optimierung nicht genutzt um das Auslesen möglichst einfach zu halten, da selbst meine komplexesten Eingaben nie mehr als 600 Zustände hatten und die Tabelle somit nie mehr als ca. 300 kB groß wahr. Der Median liegt bei 77 Zuständen also 5 kB.
    % 12 20 31 37 41 50 51 55 61 66 77 78 107 111 117 124 153 259 423 526
    \item @todo(viktor): Visuelle Darstellung
    \item Die Generierung dieser Tabelle läuft wie folgt:
    \item Ich vergleiche jeden Zustand mit sich selbst und jedem anderem Zustand indem ich für jede Himmelsrichtung prüfe ob die Farbwerte in dem Teil des Fensters zu einander identisch sind.
    \item Zum Beispiel nehmen wir den oberen-linke 2x2 Ausschnitt von Zustand A und vergleichen ihn mit dem unteren-rechten 2x2 Ausschnitt von Zustand B. Sind diese gleich so kann B im Nordwesten von A sein oder andersherum A im Südosten von B.
\end{itemize}

\section{Prozedurale Voronoi-Graphen}
@todo(viktor): Erklärung der Generierung separat zur erklärung der Anforderung an den Graphen auf dem der Algorithmus laufen soll  
\begin{itemize}
    \item Der Algorithmus arbeitet auf einem gegebenen Graphen. Die Verteilung der Zellen kann regelmäßig oder ohne Struktur sein. Es muss kann auch über den Graphen hinweg variieren. Jede Zelle hat eine 2D Position und jeder Zelle müssen alle ihre Nachbarzellen zugewiesen werden. Zellen sind benachbart, wenn sie eine Kante teilen. Eine Kante sind alle Punkte die gleichweit von zwei Zellenmittelpunkten entfernt sind. 
    \item In meiner Anwendung erstelle ich die Graphen prozedural aus einfachen Mustern oder mittels Zufallsprinzip. 
    \item Meine generierten Graphen sind immer planar, da ich immer dem selben Ablauf folge. Erst erstelle ich eine Menge an 2D Punkten, die wie gesagt eine beliebige Anordnung habe. Dann erstelle ich auf diesen Punkten eine Delaunay-Triangulierung. Das Gegenstück einer solchen Triangulierung ist ein Voronoi-Diagramm. Man findet es in dem man die Eckpunkte der Dreiecke als Mittelpunkte der Voronoizellen nimmt und die Kanten der Dreiecke enden in den Nachbarzellen jeder Zelle. Da Zellen am Rand von diesem Voronoi-Diagramm nach außen unendlich groß sind, begrenzen wir diese Zellen auf eine freigewählte rechteckige Fläche. 
    \item Zu Beginn des Wave Function Collapse werden alle Zellen mit einer Superposition aller möglichen Zustände initialisiert.
\end{itemize}

\section{Collapse Cells}
\begin{itemize}
    \item what are steps?
    \item the step control flow diagram?
    \subitem add "loop until the grid is fully collapsed"
    @todo(viktor): Erst den allgemeinen Ablauf ohne Backtracking und dann erklären wo und wie Backtracking eingebaut werden kann 
\end{itemize}

\subsection{Backtracking}
\begin{itemize}
    \item Goal, dont restart when reaching a contradiction, most of the time most of the cells are fine, only a small number of cells cause a contradiction
    \item Key Observation: for each cell the set of possible states only ever shrinks, as more and more constraints are placed on it. We never need to add back a state.
    \item For each state there is only ever one point in time when it is removed. all we need to know to advance is know which steps are removed right now.
    \item the naiive implementation creates a set of states and removes each state when it becomes impossible
    \item but We dont need to remove entries from this set, we can just store at which step in time each state became impossible and whenever we check all remaining states we ignore states that where "removed" before the current step happened
    \item Implementation: for each state in a cell store a sentinel value as the step index of removal. in the context store the current step index. after each step, increment the step index. then when propagating changes whenever a state is removed, store the current steps index as its removal timestamp. 
    \item Now we can rewind by only changing the context current step by some desired amount. the condition that checks if a state is removed now ensures that rewound removals can be detected and ignored.
\end{itemize}

\section{Datenstrukturen und Algorithmen}
\subsection{Overlap - Direction Mask / State Buckets?}
\begin{itemize}
    \item @todo(viktor): Strictness muss ich nicht mit der Größe der Zahl im Code hier gleichstellen, dass ist nur verwirrend wenn 'hohe' strictness eigentlich weniger strenge bedingungen darstellt
    \item Da Nachbarn nun in beliebigen Richtungen zu finden sind, gibt es kein direktes mapping zu den Supportregeln, welche ja je eine Menge pro Richtung sind.
    \item Dabei können wir entscheiden ob jeweils nur eine Menge oder mehrere Mengen betrachtet werden
    \item Ob eine Menge erlaubt ist, messen wir indem wir berechnen wir nahe die tatsächliche Richtung zu den Mengenrichtungen ist. Nun wählen wir die x-nähesten Mengen aus. Bei einer Strenge von 1 also die beste, bei 2 die zwei besten und so weiter.
    \item Die Strenge kann maximal 8 betrangen, da wir nur 8 "Himmelsrichtungen`` in der Extraktion genutzt haben. 
    \item Insgesamt bedeutet dies, dass ein Nachbar als z.B. im Norden oder im Nordosten betrachtet werden kann. Dadurch ist die menge an kompatiblen zuständen weniger eingeschränkt und es ist weniger wahrscheinlich, dass alle Zustände einer Zelle unmöglich werden
    \item Es folgt aber auch, dass nun Nachbar mit fast oder gar perfekter \\ übereinstimmung mit einer der Himmelsrichtung als nicht nur diese gelten, wodurch es zu einer Verzerrung im Output kommt.
    \item Wenn zuvor ein Muster im Input z.B. stehts N-S ausgerichtet war kann es ab einer Strenge vom 3 auch als (NW, N, NO)-(SW, S, SO) betrachtet werden. es könnte also auch als NW-SW betrachtet werden und aus einem Geradlinigen muster wird ein geknicktes oder zackiges.
    \item Aber genau diese auflockerung ist nötig, damit der Algorithmus mit \\ höherer Wahrscheinlichkeit eine Lösung findet
    \item 
    \item Wenn mehr Richtungen erlaubt sind, so kann dies auch betrachtet werden als dass nun nicht nur das Eingabe Muster sondern auch gedrehte Versionen der Eingabe möglich sind. 
    \item Nun können gedrehte regelmäßige Gitter auch gelöst werden. (Siehe Grid = Square with an angle ~27° and strictness 1 or 2).
    \item Auf unregelmäßigen Gittern kann man keine Drehung finden in der es einem regelmäßigen Gitter global gleich. Dennoch können Lösungen gefunden werden, da für jedes Zellenpaar/Benachbarung frei gewählt werden kann, ob eine solche gedacht Drehung angewendet wird oder nicht. 
    \item Es ist so, als würde der Algorithmus das Gitter lokal immer genau so verdrehen (mit Beschränkung durch die maximal Strictness), dass das tatsächliche Gitter lokal einem regelmäßigen gleicht.
    \item 
    \item Bei höherer Strictness und einer gelösten Zelle: ein Nachbar der Zelle kann nun aus mehr als einer Regelmenge entsprechend seiner Richtung wählen. Die Superposition des Nachbarn ist 'größer' bei höherer Strictness. Dadurch ist auch die Menge an Zuständen die Nachbarn des Nachbarn haben entsprechend größer, da weniger Beschränkungen auf sie einwirken. Es bleiben für einen längeren Zeitraum mehr Zustände möglich, wodurch ein Widerspruch durch eine Zelle mit leerer Superposition weniger wahrscheinlich ist. Im Gegenzug ist die lokale Ähnlichkeit zum Original verringert, da nun auch Nachbarn mit 'eindeutiger' Richtung zur Zelle auch einer weniger passenden Richtung zugewiesen werden können.
    \item Eine globale Strictness für alle Zellen hat einen negativen Effekt auf lokal regelmäßige Regionen eines Gitters und ein postiven Effekt auf sehr unregelmäßige Regionen des Gitters.
    \item Anstatt dass die Strictness global für alle Zellen zu Beginn bestimmt wird, kann man auch während des Collapse 'lernen' welche Regionen 'schwerer' zu lösen sind und dort die Strictness schrittweise erhöhen bis eine Lösung gefunden werden kann.
\end{itemize}

\subsection{vielleicht was zur App}