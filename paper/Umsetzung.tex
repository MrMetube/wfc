\section{State Extraction}
\begin{itemize}
    \item NxN sliding window over the input with overlap
    \item Deduplication and weighting by frequency in input
    \item wrap edges for tiling patterns or dont for example top and bottom for "vertical" patterns
\end{itemize}
\section{Support Lookup Table}
\begin{itemize}
    \item what is a state 
    \item what is a direction
    \item for a in states
    \item for b in states 
    \item for d in direction
    \item if a matches (b shifted in d) 
    \item support at (a, b, d) = true
    \item visuelle darstellung der überlappung
    \item Rules are always symmetric but this fact was not used. so the half the support table is not needed technically
\end{itemize}
\section{Generate and Setup Grid}
\begin{itemize}
    \item what do we need for a grid
    \item what do we need for a cell
    \item when generating a grid
    \subitem generate a point cloud with or without an intrisic pattern in any way you like
    \subitem generate a delaunay triangulation out of those points 
    \subitem find the dual graph, the voronoi graph, of the triangulation
    \subitem note down all neighbouring cells for each cell
    \subitem each voronoi cell becomes a cell of the grid for the wfc
    \item otherwise just manually setup a bunch of cells
    \subitem a cell needs a list of neighbouring cells
    \item for each cell initialize its states and member variables
\end{itemize}
\section{Collapse Grid}
\begin{itemize}
    \item what are steps?
    \item the step control flow diagram?
    \subitem add "loop until the grid is fully collapsed"
\end{itemize}

\section{Datenstrukturen und Algorithmen}
\section{Support - Direction Mask / State Buckets?}
\begin{itemize}
    \item the lookup table per state a, state b, direction d
    \item Da nachbarn nun in beliebigen Richtungen zu finden sind, gibt es kein direktes mapping zu den Supportregeln, welche ja je eine Menge pro Richtung sind.
    \item Dabei können wir entscheiden ob jeweils nur eine Menge oder mehrere Mengen betrachtet werden
    \item Ob eine Menge erlaubt ist, messen wir indem wir berechnen wir nahe die tatsächliche Richtung zu den Mengenrichtungen ist. Nun wählen wir die x-nähesten Mengen aus. Bei einer Strenge von 1 also die beste, bei 2 die zwei besten und so weiter.
    \item Die Strenge kann maximal 8 betrangen, da wir nur 8 "Himmelsrichtungen`` in der Extraktion genutzt haben. 
    \item Insgesamt bedeutet dies, dass ein Nachbar als z.B. im Norden oder im Nordosten betrachtet werden kann. Dadurch ist die menge an kompatiblen zuständen weniger eingeschränkt und es ist weniger wahrscheinlich, dass alle Zustände einer Zelle unmöglich werden
    \item Es folgt aber auch, dass nun Nachbar mit fast oder gar perfekter \\ übereinstimmung mit einer der Himmelsrichtung als nicht nur diese gelten, wodurch es zu einer Verzerrung im Output kommt.
    \item Wenn zuvor ein Muster im Input z.B. stehts N-S ausgerichtet war kann es ab einer Strenge vom 3 auch als (NW, N, NO)-(SW, S, SO) betrachtet werden. es könnte also auch als NW-SW betrachtet werden und aus einem Geradlinigen muster wird ein geknicktes oder zackiges.
    \item Aber genau diese auflockerung ist nötig, damit der Algorithmus mit \\ höherer Wahrscheinlichkeit eine Lösung findet
\end{itemize}
\section{Cell - Search, Collapse, Propagate}

\section{Backtracking}
\begin{itemize}
    \item Goal, dont restart when reaching a contradiction, most of the time most of the cells are fine, only a small number of cells cause a contradiction
    \item Key Observation: for each cell the set of possible states only ever shrinks, as more and more constraints are placed on it. We never need to add back a state.
    \item For each state there is only ever one point in time when it is removed. all we need to know to advance is know which steps are removed right now.
    \item the naiive implementation creates a set of states and removes each state when it becomes impossible
    \item but We dont need to remove entries from this set, we can just store at which step in time each state became impossible and whenever we check all remaining states we ignore states that where "removed" before the current step happened
    \item Implementation: for each state in a cell store a sentinel value as the step index of removal. in the context store the current step index. after each step, increment the step index. then when propagating changes whenever a state is removed, store the current steps index as its removal timestamp. 
    \item Now we can rewind by only changing the context current step by some desired amount. the condition that checks if a state is removed now ensures that rewound removals can be detected and ignored.
\end{itemize}

\section{vielleicht was zur App}